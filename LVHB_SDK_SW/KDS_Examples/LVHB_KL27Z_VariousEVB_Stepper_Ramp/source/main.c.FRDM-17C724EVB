/*
 * Copyright (c) 2013 - 2017, NXP Semiconductors, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * o Redistributions of source code must retain the above copyright notice, this list
 *   of conditions and the following disclaimer.
 *
 * o Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following disclaimer in the documentation and/or
 *   other materials provided with the distribution.
 *
 * o Neither the name of NXP Semiconductor, Inc. nor the names of its
 *   contributors may be used to endorse or promote products derived from this
 *   software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * This is template for main module created by New Kinetis SDK 2.x Project Wizard. Enjoy!
 **/

#include "board.h"
#include "pin_mux.h"
#include "clock_config.h"

#include "lvhb/lvhb.h"
#include "aml/gpio_aml.h"
#include "aml/wait_aml/wait_aml.h"

lvhb_drv_config_t drvConfig; /* LVHB driver configuration structure. */

/* Timer interrupt handler. It clears an interrupt flag
 * and call on counter restart handler from LVHB driver.
 */
void TPM0_IRQHandler(void)
{
    uint16_t status;
    uint16_t enIntMask;

    status = TMR_AML_GetStatusFlags(drvConfig.tmrInstance);
    enIntMask = TMR_AML_GetEnabledInterrupts(drvConfig.tmrInstance);

    if (((tmrStsTimeOverflow & status) != 0U) &&
            ((tmrIntTimeOverflow & enIntMask) != 0U))
    {
        TMR_AML_ClearStatusFlags(drvConfig.tmrInstance, tmrStsTimeOverflow);

        /* Invoke OnCounterRestart MVHB event */
        LVHB_OnCounterRestart(&drvConfig);
    }
}

/*
 * On LVHB action complete event handler.
 */
void LVHB_OnActionComplete(lvhb_drv_config_t* const drvConfig)
{
    AML_UNUSED(drvConfig);
}

/*
 * Wait for completion of motor movement.
 */
static void WaitForCompletion(lvhb_drv_config_t* const drvConfig)
{
    while (LVHB_GetMotorStatus(drvConfig) == lvhbStatusRunning);
}

/*
* Function contains endless loop with several test cases
* intended to control stepper motor.
*
* Return FALSE if an error occurred.
*/
static bool StartApplication(lvhb_drv_config_t* const drvConfig)
{
    /* Initial speed in full-step mode. Micro-stepping speed is derived from
    * full-stepping speed. */
    const uint16_t INIT_SPEED = 200;
    const uint16_t MAX_SPEED = 500;   /* Maximal speed. */
    uint16_t speed = INIT_SPEED;      /* Current motor speed. */

    /* Align motor to full-step position. */
    if (LVHB_AlignRotor(drvConfig) != kStatus_Success)
    {
        return false;
    }

    WaitForCompletion(drvConfig);

    while (true)
    {
        /* Set full-step speed. */
        if (LVHB_SetFullStepSpeed(drvConfig, speed) != kStatus_Success)
        {
            return false;
        }

        /* Move 800 full-steps in forward. */
        if (LVHB_MoveSteps(drvConfig, true, 800) != kStatus_Success)
        {
            return false;
        }

        /* Wait while motor is running. */
        WaitForCompletion(drvConfig);

        /* Set micro-step size to 8. */
        if (LVHB_SetMicroStepSize(drvConfig, lvhbMicroStep8) != kStatus_Success)
        {
            return false;
        }

        if (LVHB_SetMicroStepSpeed(drvConfig, speed * 8) != kStatus_Success)
        {
            return false;
        }

        /* Move motor by 3200 micro-steps (i.e. 800 full-steps) in reverse direction. */
        if (LVHB_MoveMicroSteps(drvConfig, false, 800 * 8) != kStatus_Success)
        {
            return false;
        }

        /* Wait while motor is running. */
        WaitForCompletion(drvConfig);

        /* Set micro-step size to 2. */
        if (LVHB_SetMicroStepSize(drvConfig, lvhbMicroStep2) != kStatus_Success)
        {
            return false;
        }

        if (LVHB_SetMicroStepSpeed(drvConfig, speed * 2) != kStatus_Success)
        {
            return false;
        }

        /* Move motor by 800 micro-steps (i.e. 800 full-steps) in reverse direction. */
        if (LVHB_MoveMicroSteps(drvConfig, false, 800 * 2) != kStatus_Success)
        {
            return false;
        }

        /* Wait while motor is running. */
        WaitForCompletion(drvConfig);

        /* Increase speed. */
        speed += 100;
        if (speed > MAX_SPEED)
        {
            speed = INIT_SPEED;
        }

        /* Wait for a while and hold current motor position. */
        WAIT_AML_WaitSec(1);
    }
}

/*!
 * @brief Application entry point.
 */
int main(void) {

    /* Init board hardware. */
    BOARD_InitPins();
    BOARD_BootClockRUN();

    /* Add your code here. */
    /* Fill LVHB driver config. */
    LVHB_GetDefaultConfig(&drvConfig, lvhbDeviceMPC17C724, lvhbMotorStepper);

    drvConfig.deviceConfig.stepperConfig.fullStepSpeed = 200;
    drvConfig.deviceConfig.stepperConfig.fullStepAcceleration = 200;
    drvConfig.deviceConfig.stepperConfig.microStepPerStep = lvhbMicroStep8;
    drvConfig.deviceConfig.stepperConfig.microStepPwmFrequency = 20000;
    drvConfig.deviceConfig.stepperConfig.microStepSpeed = 400;
    drvConfig.deviceConfig.stepperConfig.microStepAcceleration = 400;

    /* Timer settings */
    drvConfig.tmrInstance = 0;                                  /* TPM0 */
    drvConfig.tmrLvhbConfig.counterWidth = 16;
    drvConfig.tmrLvhbConfig.prescale = tmrPrescDiv_8;
    drvConfig.tmrLvhbConfig.srcClck_Hz = CLOCK_GetFreq(kCLOCK_McgIrc48MClk);

    /* Pins */
    drvConfig.inputPins[lvhbBridge1] = lvhbPinsPwm;             /* IN1A (PWM) + IN1B (PWM) */
    drvConfig.inputPins[lvhbBridge2] = lvhbPinsPwm;             /* IN2A (PWM) + IN2B (PWM) */
    drvConfig.tmrLvhbConfig.inxaChannelNumber[lvhbBridge1] = 0; /* IN1A - PTE24/TPM0_CH0 */
    drvConfig.tmrLvhbConfig.inxbChannelNumber[lvhbBridge1] = 5; /* IN1B - PTC9/TPM0_CH5 */
    drvConfig.tmrLvhbConfig.inxaChannelNumber[lvhbBridge2] = 4; /* IN2A - PTE31/TPM0_CH4 */
    drvConfig.tmrLvhbConfig.inxbChannelNumber[lvhbBridge2] = 2; /* IN2B - PTA5/TPM0_CH2 */

    drvConfig.enPinInstance = instanceA;                        /* EN - PTA2 */
    drvConfig.enPinIndex = 2;

    /* Turn off RED LED. */
    GPIO_AML_SetDirection(instanceB, BOARD_LED_RED_GPIO_PIN, gpioDirDigitalOutput);
    GPIO_AML_SetOutput(instanceB, BOARD_LED_RED_GPIO_PIN);

    CLOCK_SetTpmClock(kTPM_SystemClock);

    /* Initialize GPIO pins, timer and LVHB driver. */
    if ((LVHB_ConfigureGpio(&drvConfig) != kStatus_Success) ||
        (LVHB_ConfigureTimer(&drvConfig, NULL) != kStatus_Success) ||
        (LVHB_Init(&drvConfig) != kStatus_Success))
    {
        /* An error occurred during initialization. */
        GPIO_AML_ClearOutput(instanceB, BOARD_LED_RED_GPIO_PIN);
    }
    else
    {
        /* Enable interrupts for TPM0. */
        EnableIRQ(TPM0_IRQn);

        /* Set active mode and run the demo application. */
        if (LVHB_SetMode(&drvConfig, true) != kStatus_Success)
        {
            /* An error occurred. */
            GPIO_AML_ClearOutput(instanceB, BOARD_LED_RED_GPIO_PIN);
        }
        else if (!StartApplication(&drvConfig))
        {
            /* An error occurred. */
            GPIO_AML_ClearOutput(instanceB, BOARD_LED_RED_GPIO_PIN);
            LVHB_SetMode(&drvConfig, false);
        }
    }

    for(;;)  /* Infinite loop to avoid leaving the main function */
    {
        __asm("NOP"); /* something to use as a breakpoint stop while looping */
    }
}

